{"version":3,"file":"static/js/212.75fd8157.chunk.js","mappings":"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","sources":["2048.js"],"sourcesContent":["import { useState, useEffect } from \"react\";\r\n\r\nconst SIZE = 4;\r\nconst WILDCARD = -1;\r\n\r\nconst STORAGE_KEY = `react2048`; // for local storage\r\n\r\nconst CELL_PX = 80; // height and width for .cell2048 (css modify needed if changed)\r\nconst GAP_PX = 10;  // gap for .grid2048\r\nconst PAD_PX = 10;  // padding for .grid2048 (css modify needed if changed)\r\n\r\n// ------------------ helper functions ------------------\r\nfunction emptyBoard(size) {\r\n  return Array.from({ length: size }, () => Array(size).fill(0));\r\n}\r\n\r\nfunction getEmptyCells(board) {\r\n  const cells = [];\r\n  for (let r = 0; r < board.length; r++) {\r\n    for (let c = 0; c < board[r].length; c++) {\r\n      if (board[r][c] === 0) cells.push([r, c]);\r\n    }\r\n  }\r\n  return cells;\r\n}\r\n\r\nfunction addRandomTile(board) {\r\n  const empties = getEmptyCells(board);\r\n  if (empties.length === 0) return board;\r\n\r\n  const [r, c] = empties[Math.floor(Math.random() * empties.length)];\r\n  const next = board.map(row => row.slice());\r\n\r\n  if (Math.random() < 0.3) next[r][c] = WILDCARD;  // 30% chance to generate ??\r\n  else next[r][c] = Math.random() < 0.9 ? 2 : 4; // then the lefting 10% chance to be 4\r\n\r\n  return next;\r\n}\r\n\r\nfunction initBoard() {\r\n  let b = emptyBoard(SIZE);\r\n  b = addRandomTile(b);\r\n  b = addRandomTile(b);\r\n  return b;\r\n}\r\n\r\nfunction canMerge(a, b) {\r\n  const aWild = a === WILDCARD;\r\n  const bWild = b === WILDCARD;\r\n  return (a === b && !aWild) || (aWild !== bWild);\r\n}\r\n\r\nfunction mergedValue(a, b) {\r\n  const aWild = a === WILDCARD;\r\n  const bWild = b === WILDCARD;\r\n  if (aWild && bWild) return 0;\r\n  const num = aWild ? b : a;\r\n  return num * 2;\r\n}\r\n\r\nfunction rotateBoardLeft(board) {\r\n  const N = board.length;\r\n  const res = emptyBoard(N);\r\n  for (let r = 0; r < N; r++) {\r\n    for (let c = 0; c < N; c++) {\r\n      res[N - 1 - c][r] = board[r][c];\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\nfunction rotateBoardRight(board) {\r\n  const N = board.length;\r\n  const res = emptyBoard(N);\r\n  for (let r = 0; r < N; r++) {\r\n    for (let c = 0; c < N; c++) {\r\n      res[c][N - 1 - r] = board[r][c];\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\nfunction flipBoard(board) {\r\n  return board.map(row => row.slice().reverse());\r\n}\r\n\r\nfunction findSpawnKeys(before, after) {\r\n  const keys = [];\r\n  for (let r = 0; r < before.length; r++) {\r\n    for (let c = 0; c < before[r].length; c++) {\r\n      if (before[r][c] === 0 && after[r][c] !== 0) {\r\n        keys.push(`${r}-${c}`);\r\n      }\r\n    }\r\n  }\r\n  return keys;\r\n}\r\n\r\n// ------------------ major merge logic ------------------\r\nfunction traceLineLeftWithMoves(line) {\r\n  const entries = [];  // all non-null elements and their buffers\r\n  for (let c = 0; c < line.length; c++) if (line[c] !== 0)\r\n    entries.push({ v: line[c], fromC: c });\r\n\r\n  const merged = [];\r\n  const moves = [];\r\n  const mergedDestCols = [];\r\n  let gained = 0;\r\n  let target = 0;\r\n\r\n  for (let i = 0; i < entries.length; i++) {\r\n    const a = entries[i];\r\n    const b = entries[i + 1];\r\n\r\n    if (b && canMerge(a.v, b.v)) {\r\n      const val = mergedValue(a.v, b.v);\r\n      merged.push(val);\r\n      moves.push({ fromC: a.fromC, toC: target, v: a.v, willMerge: true });\r\n      moves.push({ fromC: b.fromC, toC: target, v: b.v, willMerge: true });\r\n      mergedDestCols.push(target);\r\n      gained += val;\r\n      target++;\r\n      i++;\r\n    }\r\n    else {\r\n      merged.push(a.v);\r\n      moves.push({ fromC: a.fromC, toC: target, v: a.v, willMerge: false });\r\n      target++;\r\n    }\r\n  }\r\n\r\n  while (merged.length < line.length) merged.push(0);\r\n  const moved = moves.some(m => m.fromC !== m.toC);\r\n\r\n  return { merged, moves, mergedDestCols, moved, gained };\r\n}\r\n\r\nfunction computeMoveWithTrace(board, dir) {\r\n  const N = board.length;\r\n\r\n  let working = board.map(r => r.slice());\r\n  if (dir === \"up\") working = rotateBoardLeft(working);\r\n  else if (dir === \"down\") working = rotateBoardRight(working);\r\n  else if (dir === \"right\") working = flipBoard(working);\r\n\r\n  const mergedRows = [];\r\n  const rowMoves = [];\r\n  const mergedDestsWorking = [];\r\n  let gainedTotal = 0;\r\n  let movedAny = false;\r\n\r\n  for (let r = 0; r < N; r++) {\r\n    const { merged, moves, mergedDestCols, moved, gained } = traceLineLeftWithMoves(working[r]);\r\n    mergedRows.push(merged);\r\n    rowMoves.push({ r, moves });\r\n    mergedDestCols.forEach(c => mergedDestsWorking.push({ r, c }));\r\n    if (moved) movedAny = true;\r\n    gainedTotal += gained;\r\n  }\r\n\r\n  let next =\r\n    dir === \"up\" ? rotateBoardRight(mergedRows) :\r\n      dir === \"down\" ? rotateBoardLeft(mergedRows) :\r\n        dir === \"right\" ? flipBoard(mergedRows) :\r\n          mergedRows;\r\n\r\n  function fromWorkingToOriginal_src(rw, cw) {\r\n    if (dir === \"left\") return { r: rw, c: cw };\r\n    if (dir === \"up\") return { r: cw, c: N - 1 - rw };\r\n    if (dir === \"down\") return { r: N - 1 - cw, c: rw };\r\n\r\n    return { r: rw, c: N - 1 - cw };\r\n  }\r\n  function fromWorkingToOriginal_dst(rw, cw) {\r\n\r\n    if (dir === \"left\") return { r: rw, c: cw };\r\n    if (dir === \"up\") return { r: cw, c: N - 1 - rw };\r\n    if (dir === \"down\") return { r: N - 1 - cw, c: rw };\r\n\r\n    return { r: rw, c: N - 1 - cw };\r\n  }\r\n\r\n  const moves = [];\r\n  rowMoves.forEach(({ r: rw, moves: ms }) => {\r\n    ms.forEach(m => {\r\n      const src = fromWorkingToOriginal_src(rw, m.fromC);\r\n      const dst = fromWorkingToOriginal_dst(rw, m.toC);\r\n      moves.push({ fromR: src.r, fromC: src.c, toR: dst.r, toC: dst.c, v: m.v, willMerge: m.willMerge });\r\n    });\r\n  });\r\n\r\n  const mergedDest = mergedDestsWorking.map(({ r: rw, c: cw }) => fromWorkingToOriginal_dst(rw, cw));\r\n\r\n  return { next, movedAny, gainedTotal, moves, mergedDest };\r\n}\r\n\r\nfunction isGameOver(board) {\r\n  if (getEmptyCells(board).length > 0) return false;\r\n\r\n  const N = board.length;\r\n\r\n  for (let r = 0; r < N; r++) {\r\n    for (let c = 0; c < N; c++) {\r\n      const v = board[r][c];\r\n\r\n      if (c + 1 < N) {\r\n        const w = board[r][c + 1];\r\n        const canMergeRight = (v === w && v !== WILDCARD) || ((v === WILDCARD) !== (w === WILDCARD));\r\n        if (canMergeRight) return false;\r\n      }\r\n\r\n      if (r + 1 < N) {\r\n        const w = board[r + 1][c];\r\n        const canMergeDown = (v === w && v !== WILDCARD) || ((v === WILDCARD) !== (w === WILDCARD));\r\n        if (canMergeDown) return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// ------------------ style & render ------------------\r\nfunction tileClass(v) {\n  if (v === WILDCARD) return \"cell2048 wild2048\";\n  if (!v) return \"cell2048 v0\";\n\n  // Cycle colors after 8192 using a fixed palette and integer exponent.\n  const palette = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192];\n  let exp = Math.round(Math.log2(Math.abs(v))); // robust to float noise\n  if (!Number.isFinite(exp) || exp < 1) exp = 1;\n  const normVal = palette[(exp - 1) % palette.length];\n  return `cell2048 v${normVal}`;\n}\n\nfunction formatTileValue(v) {\n  if (v === WILDCARD) return \"??\";\n  if (!v) return \"\";\n  if (v > 8192) {\n    const s = String(v);\n    if (s.length > 2) return `${s[0]}...${s[s.length - 1]}`;\n  }\n  return String(v);\n}\n\r\nfunction keyOf(r, c) { return `${r}-${c}`; }\r\n\r\nfunction cellXY(r, c) {\r\n  const x = c * (CELL_PX + GAP_PX);\r\n  const y = r * (CELL_PX + GAP_PX);\r\n  return { x, y };\r\n}\r\n\r\nfunction scoreToHueDuration(score) {\r\n  const threshold = 10000;\r\n  if (score < threshold) return null;\r\n\r\n  const extra = score - threshold;\r\n\r\n  const base = 4.5;     // anim speed, seconds for one round\r\n  const decay = 0.85;\r\n  const step = 2000;\r\n  const min  = 0.7;     // the top limit of anim speed\r\n\r\n  const dur = base * Math.pow(decay, Math.floor(extra / step));\r\n  return Math.max(min, dur);\r\n}\r\n\r\n\r\n// ------------------ result to return ------------------\r\nexport default function Game2048() {\r\n  // inner const:\r\n  const [board, setBoard] = useState(() => initBoard());\r\n  const [score, setScore] = useState(0);\r\n  const [over, setOver] = useState(false);\r\n  const [prevBoard, setPrevBoard] = useState(null);\r\n  const [prevScore, setPrevScore] = useState(0);\r\n  const [prevOver, setPrevOver] = useState(false);\r\n  const [canUndo, setCanUndo] = useState(false);\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n\r\n  const [animTiles, setAnimTiles] = useState([]);\r\n  const [animPlay, setAnimPlay] = useState(false);\r\n  const [movingFrom, setMovingFrom] = useState(() => new Set());\r\n  const [flashCells, setFlashCells] = useState(() => new Set());\r\n  const [spawnCells, setSpawnCells] = useState(() => new Set());\r\n\r\n  const [best, setBest] = useState(() => {\r\n    const raw = localStorage.getItem(STORAGE_KEY);\r\n    const n = raw == null ? 0 : Number(raw);\r\n    return Number.isFinite(n) ? n : 0;\r\n  });\r\n\r\n  const SPAWN_MS = 140; // the time for spawn animation\r\n  const MOVE_MS = 65;  // the time for move animation\r\n  const FLASH_MS = 140;\r\n\r\n  // inner functions:\r\n  function handleNewGame() {\r\n    const b = initBoard();\r\n    setBoard(b);\r\n    setScore(0);\r\n    setOver(false);\r\n\r\n    // clear animation\r\n    setAnimTiles([]);\r\n    setMovingFrom(new Set());\r\n    setFlashCells(new Set());\r\n    setSpawnCells(new Set());\r\n    setAnimPlay(false);\r\n    setIsAnimating(false);\r\n\r\n    // clear undo\r\n    setPrevBoard(null);\r\n    setPrevScore(0);\r\n    setPrevOver(false);\r\n    setCanUndo(false);\r\n\r\n    // 2 nums spawn when start new\r\n    const initSpawn = [];\r\n    for (let r = 0; r < SIZE; r++) {\r\n      for (let c = 0; c < SIZE; c++) {\r\n        if (b[r][c] !== 0) initSpawn.push(`${r}-${c}`);\r\n      }\r\n    }\r\n    setSpawnCells(new Set(initSpawn));\r\n    window.setTimeout(() => setSpawnCells(new Set()), SPAWN_MS);\r\n  }\r\n\r\n  function handleMove(dir) {\r\n    if (over || isAnimating) return;\r\n\r\n    const { next, movedAny, gainedTotal, moves, mergedDest } = computeMoveWithTrace(board, dir);\r\n    if (!movedAny) return;\r\n\r\n    // save snapshot for undo\r\n    setPrevBoard(board.map(row => row.slice()));\r\n    setPrevScore(score);\r\n    setPrevOver(over);\r\n    setCanUndo(true);\r\n\r\n    // play moving animation\r\n    setIsAnimating(true);\r\n    setAnimTiles(moves);\r\n    setMovingFrom(new Set(moves.map(m => keyOf(m.fromR, m.fromC))));\r\n    setAnimPlay(false);\r\n    requestAnimationFrame(() => requestAnimationFrame(() => setAnimPlay(true)));\r\n\r\n    window.setTimeout(() => {\r\n      const withTile = addRandomTile(next);\r\n\r\n      const spawn = findSpawnKeys(next, withTile);\r\n      if (spawn.length) {\r\n        setSpawnCells(new Set(spawn));\r\n        window.setTimeout(() => setSpawnCells(new Set()), SPAWN_MS);\r\n      }\r\n\r\n      setBoard(withTile);\r\n      setScore(s => s + gainedTotal);\r\n      setAnimTiles([]);\r\n      setMovingFrom(new Set());\r\n      setFlashCells(new Set(mergedDest.map(p => keyOf(p.r, p.c))));\r\n      if (isGameOver(withTile)) setOver(true);\r\n\r\n      window.setTimeout(() => setFlashCells(new Set()), FLASH_MS);\r\n      setIsAnimating(false);\r\n    }, MOVE_MS);\r\n  }\r\n\r\n  function handleUndo() {\r\n    if (!canUndo || isAnimating) return;\r\n    if (!prevBoard) return;\r\n\r\n    // back to last snapshot\r\n    setBoard(prevBoard);\r\n    setScore(prevScore);\r\n    setOver(prevOver);\r\n\r\n    // clear\r\n    setAnimTiles([]);\r\n    setMovingFrom(new Set());\r\n    setFlashCells(new Set());\r\n    setSpawnCells(new Set());\r\n    setAnimPlay(false);\r\n\r\n    // allow only one undo at a time\r\n    setCanUndo(false);\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (score > best) {\r\n      setBest(score);\r\n      localStorage.setItem(STORAGE_KEY, String(score));\r\n    }\r\n  }, [score, best]);\r\n\r\n  useEffect(() => {\r\n    const onKey = (e) => {\r\n      const key = e.key.toLowerCase();\r\n      const map = {\r\n        arrowup: \"up\",\r\n        arrowdown: \"down\",\r\n        arrowleft: \"left\",\r\n        arrowright: \"right\",\r\n        w: \"up\",\r\n        s: \"down\",\r\n        a: \"left\",\r\n        d: \"right\",\r\n      };\r\n      const dir = map[key];\r\n      if (!dir) return;\r\n      e.preventDefault();\r\n      handleMove(dir);\r\n    };\r\n    window.addEventListener(\"keydown\", onKey);\r\n    return () => window.removeEventListener(\"keydown\", onKey);\r\n  }, [board, over]);\r\n\r\n  return (\r\n    <div className=\"container2048\">\r\n\r\n      <div className=\"instruction2048\">\r\n        <p>Control Keys:</p>\r\n        <p>Buttons below or \"AWSD\" on your keyboard</p>\r\n        <p>Note:</p>\r\n        <p>?? can merge with any numbers but itself</p>\r\n      </div>\r\n\r\n      <div className=\"header2048\">\r\n        <h2 className=\"title2048\">2048</h2>\r\n        <div style={{ display: \"flex\", gap: 8, alignItems: \"center\" }}>\r\n          {(() => {\r\n            const dur = scoreToHueDuration(score);\r\n            const cls = \"score2048\" + (dur ? \" animateHue2048\" : \"\");\r\n            const style = dur ? { \"--hueDur\": `${dur}s` } : undefined;\r\n            return <span className={cls} style={style}>Score: {score}</span>;\r\n          })()}\r\n\r\n          {(() => {\r\n            const dur = scoreToHueDuration(best);\r\n            const cls = \"best2048\" + (dur ? \" animateHue2048\" : \"\");\r\n            const style = dur ? { \"--hueDur\": `${dur}s` } : undefined;\r\n            return <span className={cls} style={style}>Best: {best}</span>;\r\n          })()}\r\n          <button className=\"btn2048\" onClick={handleNewGame}>New Game</button>\r\n        </div>\r\n      </div>\r\n\r\n      {over && (<p className=\"GameOver2048\"> Game Over </p>)}\r\n\r\n      <div className=\"undoButton2048wapper\">\r\n        <button\r\n          className=\"btn2048 undoButton2048\"\r\n          onClick={handleUndo}\r\n          disabled={!canUndo}>\r\n          Undo\r\n        </button>\r\n      </div>\r\n\r\n      <div className=\"boardWrap2048\">\r\n        <div className=\"grid2048\" style={{ \"--cols\": SIZE }}>\r\n          {board.map((row, r) =>\r\n            row.map((value, c) => {\r\n              const k = keyOf(r, c);\r\n              const hide = movingFrom.has(k);\r\n              const flash = flashCells.has(k);\r\n              const isSpawn = spawnCells.has(k);\r\n\r\n              const cls = tileClass(value) +\r\n                (hide ? \" movingOut2048\" : \"\") +\r\n                (flash ? \" flash2048\" : \"\") +\r\n                (isSpawn ? \" spawn2048\" : \"\");\r\n\r\n              return (\n                <div key={k} className={cls}>\n                  {formatTileValue(value)}\n                </div>\n              );\n            })\r\n          )}\r\n        </div>\r\n        {/* render the moving nums */}\r\n        <div className=\"animLayer2048\">\r\n          {animTiles.map((m, idx) => {\r\n            const from = cellXY(m.fromR, m.fromC);\r\n            const to = cellXY(m.toR, m.toC);\r\n            const dx = to.x - from.x;\r\n            const dy = to.y - from.y;\r\n\r\n            const style = {\r\n              left: from.x,\r\n              top: from.y,\r\n              transform: `translate3d(${animPlay ? dx : 0}px, ${animPlay ? dy : 0}px, 0)`,\r\n              transitionDuration: `${MOVE_MS}ms`,\r\n            };\r\n\r\n            return (\r\n              <div key={idx} className=\"movingTile2048\">\r\n                <div className={`movingInner2048 ${tileClass(m.v)}`} style={style}>\n                  {formatTileValue(m.v)}\n                </div>\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"controls2048\" role=\"group\" aria-label=\"Move controls\">\r\n        <div />\r\n        <button className=\"btn2048 arrowBtn2048\" onClick={() => handleMove(\"up\")} aria-label=\"Up\">üîº</button>\r\n        <div />\r\n\r\n        <button className=\"btn2048 arrowBtn2048\" onClick={() => handleMove(\"left\")} aria-label=\"Left\">‚óÄÔ∏è</button>\r\n        <div />\r\n        <button className=\"btn2048 arrowBtn2048\" onClick={() => handleMove(\"right\")} aria-label=\"Right\">‚ñ∂Ô∏è</button>\r\n\r\n        <div />\r\n        <button className=\"btn2048 arrowBtn2048\" onClick={() => handleMove(\"down\")} aria-label=\"Down\">üîΩ</button>\r\n        <div />\r\n      </div>\r\n\r\n    </div>\r\n  );\r\n}\n"],"names":["SIZE","WILDCARD","STORAGE_KEY","CELL_PX","GAP_PX","emptyBoard","size","Array","from","length","fill","getEmptyCells","board","cells","r","c","push","addRandomTile","empties","Math","floor","random","next","map","row","slice","initBoard","b","canMerge","a","aWild","mergedValue","rotateBoardLeft","N","res","rotateBoardRight","flipBoard","reverse","traceLineLeftWithMoves","line","entries","v","fromC","merged","moves","mergedDestCols","gained","target","i","val","toC","willMerge","moved","some","m","computeMoveWithTrace","dir","working","mergedRows","rowMoves","mergedDestsWorking","gainedTotal","movedAny","forEach","fromWorkingToOriginal_dst","rw","cw","_ref","ms","src","fromWorkingToOriginal_src","dst","fromR","toR","mergedDest","_ref2","tileClass","palette","exp","round","log2","abs","Number","isFinite","concat","formatTileValue","s","String","keyOf","cellXY","x","y","scoreToHueDuration","score","extra","dur","pow","max","Game2048","setBoard","useState","setScore","over","setOver","prevBoard","setPrevBoard","prevScore","setPrevScore","prevOver","setPrevOver","canUndo","setCanUndo","isAnimating","setIsAnimating","animTiles","setAnimTiles","animPlay","setAnimPlay","movingFrom","setMovingFrom","Set","flashCells","setFlashCells","spawnCells","setSpawnCells","best","setBest","raw","localStorage","getItem","n","handleMove","requestAnimationFrame","window","setTimeout","withTile","spawn","before","after","keys","findSpawnKeys","p","w","isGameOver","useEffect","setItem","onKey","e","arrowup","arrowdown","arrowleft","arrowright","d","key","toLowerCase","preventDefault","addEventListener","removeEventListener","_jsxs","className","children","_jsx","style","display","gap","alignItems","cls","undefined","onClick","initSpawn","disabled","value","k","hide","has","flash","isSpawn","idx","to","dx","dy","left","top","transform","transitionDuration","role"],"sourceRoot":""}