{"version":3,"file":"static/js/476.e9847544.chunk.js","mappings":"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","sources":["Gomoku.js"],"sourcesContent":["import React, { useMemo, useState } from \"react\";\r\n\r\n// const parameters\r\nconst EMPTY = 0, BLACK = 1, WHITE = 2;\r\nconst PIECE_CHAR = { [EMPTY]: \"\", [BLACK]: \"üêÆ\", [WHITE]: \"1Ô∏è‚É£\" };\r\n\r\nconst DIRS = [\r\n    [0, 1],   // ‚Üí\r\n    [1, 0],   // ‚Üì\r\n    [1, 1],   // ‚Üò\r\n    [1, -1],  // ‚Üô\r\n];\r\n\r\n// create the chesse board\r\nfunction createEmptyBoard(n) {\r\n    return Array.from({ length: n }, () => Array(n).fill(EMPTY));\r\n}\r\n\r\n// check if out of the board bundary\r\nfunction inBounds(board, r, c) {\r\n    const rows = board.length;\r\n    const cols = rows > 0 ? board[0].length : 0;\r\n    return r >= 0 && r < rows && c >= 0 && c < cols;\r\n}\r\n\r\nfunction collectLine(board, r, c, dr, dc) {\r\n    const color = board[r][c];\r\n    if (color === EMPTY) return [];\r\n\r\n    const line = [[r, c]];\r\n\r\n    // forward\r\n    let rr = r + dr, cc = c + dc;\r\n    while (inBounds(board, rr, cc) && board[rr][cc] === color) {\r\n        line.push([rr, cc]);\r\n        rr += dr; cc += dc;\r\n    }\r\n\r\n    // reverse\r\n    rr = r - dr; cc = c - dc;\r\n    while (inBounds(board, rr, cc) && board[rr][cc] === color) {\r\n        line.unshift([rr, cc]);\r\n        rr -= dr; cc -= dc;\r\n    }\r\n\r\n    return line;\r\n}\r\n\r\nfunction checkWinner(r, c, board) {\r\n    const color = board[r][c];\r\n    if (color === EMPTY) return null;\r\n\r\n    for (const [dr, dc] of DIRS) {\r\n        const line = collectLine(board, r, c, dr, dc, color);\r\n\r\n        if (line.length >= 5) return { winner: color, line }; // highlight the line of 5\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * @param {number} size - size of the board\r\n * @param {number} cell - pixiel per block\r\n */\r\n\r\nexport default function Gomoku({ size = 19, cell = 36 }) {\r\n    const [board, setBoard] = useState(() => createEmptyBoard(size));\r\n    const [current, setCurrent] = useState(BLACK); // black first\r\n    const [winner, setWinner] = useState(null);\r\n    const [winningLine, setWinningLine] = useState([]);\r\n    const [lastSnapshot, setLastSnapshot] = useState(null); // board, current\r\n    const [canUndo, setCanUndo] = useState(false);\r\n\r\n    function handleCellClick(r, c) {\r\n        if (winner || board[r][c] !== EMPTY) return;\r\n\r\n        // save last board snapshot\r\n        const snapshot = {\r\n            board: board.map(row => row.slice()),\r\n            current: current,\r\n        };\r\n        setLastSnapshot(snapshot);\r\n        setCanUndo(true);\r\n\r\n        // copy board and place chess\r\n        const next = board.map(row => row.slice());\r\n        next[r][c] = current;\r\n\r\n        // update the board and check winner\r\n        const result = checkWinner(r, c, next);\r\n        setBoard(next);\r\n\r\n        if (result) {\r\n            setWinner(result.winner);\r\n            setWinningLine(result.line);\r\n            return;\r\n        }\r\n\r\n        setCurrent(p => (p === BLACK ? WHITE : BLACK));\r\n    }\r\n\r\n    function handleUndo() {\r\n        if (!canUndo || !lastSnapshot) return;\r\n\r\n        setBoard(lastSnapshot.board);\r\n        setCurrent(lastSnapshot.current);\r\n        setWinner(null);\r\n        setWinningLine([]);\r\n\r\n        setCanUndo(false);\r\n        setLastSnapshot(null);\r\n    }\r\n\r\n    function handleReset() {\r\n        setBoard(createEmptyBoard(size));\r\n        setCurrent(BLACK);\r\n        setWinner(null);\r\n        setWinningLine([]);\r\n        setCanUndo(false);\r\n        setLastSnapshot(null);\r\n    }\r\n\r\n    return (\r\n        <div className=\"gomoku\">\r\n            <div className=\"gomoku_panel\">\r\n                <strong>Gomoku</strong>\r\n                <span>\r\n                    Turn: {current === BLACK ? <b>üêÆ</b> : <b>üëà1Ô∏è‚É£</b>}\r\n                </span>\r\n                {winner && (\r\n                    <span>\r\n                        Winner: {winner === BLACK ? <b>Player üêÆ</b> : <b>Player üëà1Ô∏è‚É£</b>}\r\n                    </span>\r\n                )}\r\n            </div>\r\n\r\n            <div className=\"gomoku_operation\">\r\n                <button onClick={handleUndo} disabled={!canUndo}>Undo</button>\r\n                <button onClick={handleReset}>Reset</button>\r\n            </div>\r\n\r\n            <div\r\n                className=\"gomoku_board\"\r\n                style={{\r\n                    gridTemplateColumns: `repeat(${size}, ${cell}px)`,\r\n                    gridTemplateRows: `repeat(${size}, ${cell}px)`,\r\n                }}\r\n            >\r\n                {board.map((row, r) =>\r\n                    row.map((val, c) => {\r\n                        const isWinCell = winningLine.some(\r\n                            ([rr, cc]) => rr === r && cc === c\r\n                        );\r\n                        return (\r\n                            <button\r\n                                key={`${r}-${c}`}\r\n                                className={`gomoku_cell ${isWinCell ? \"win\" : \"\"}`}\r\n                                onClick={() => handleCellClick(r, c)}\r\n                                aria-label={`row ${r + 1}, col ${c + 1}, ${val === EMPTY ? \"empty\" : val === BLACK ? \"black\" : \"white\"\r\n                                    }`}\r\n                                style={{ fontSize: `${Math.floor(cell * 0.7)}px` }}\r\n                            >\r\n                                {PIECE_CHAR[val]}\r\n                            </button>\r\n                        );\r\n                    })\r\n                )}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n"],"names":["EMPTY","BLACK","WHITE","PIECE_CHAR","DIRS","createEmptyBoard","n","Array","from","length","fill","inBounds","board","r","c","rows","cols","collectLine","dr","dc","color","line","rr","cc","push","unshift","Gomoku","_ref","size","cell","setBoard","useState","current","setCurrent","winner","setWinner","winningLine","setWinningLine","lastSnapshot","setLastSnapshot","canUndo","setCanUndo","handleCellClick","snapshot","map","row","slice","next","result","checkWinner","p","_jsxs","className","children","_jsx","onClick","disabled","style","gridTemplateColumns","concat","gridTemplateRows","val","isWinCell","some","_ref2","fontSize","Math","floor"],"sourceRoot":""}